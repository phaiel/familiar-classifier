use std::env;
use std::fs;
use std::path::Path;
use serde_json::{Value, Map};

fn main() {
    let schemas_json_path = "../assets/schemas.json";
    println!("cargo:rerun-if-changed={}", schemas_json_path);

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated.rs");

    let schema_content = fs::read_to_string(schemas_json_path)
        .expect("Failed to read schemas.json");
    let rust_code = generate_rust_from_json_schema(&schema_content);

    fs::write(&dest_path, rust_code).expect("Failed to write generated schemas");
}

fn json_type_to_rust(schema: &Value) -> String {
    if let Some(ref_path) = schema.get("$ref") {
        return ref_path.as_str().unwrap().split('/').last().unwrap().to_string();
    }
    
    let json_type = schema.get("type").and_then(|v| v.as_str()).unwrap_or("object");
    match json_type {
        "string" => "String".to_string(),
        "number" => "f64".to_string(),
        "integer" => "i64".to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let items_obj = schema.get("items").expect("Array must have 'items' property");
            format!("Vec<{}>", json_type_to_rust(items_obj))
        },
        "object" => "HashMap<String, Value>".to_string(),
        _ => "Value".to_string(),
    }
}

fn generate_rust_from_json_schema(schema_content: &str) -> String {
    let schema: Value = serde_json::from_str(schema_content).expect("Failed to parse JSON schema");
    let models = schema.get("models").and_then(|v| v.as_object()).expect("Schema must have a 'models' object");

    let mut rust_code = String::new();
    rust_code.push_str("// DO NOT EDIT. This file is auto-generated by build.rs\n\n");
    rust_code.push_str("use serde::{Serialize, Deserialize};\n");
    rust_code.push_str("use std::collections::HashMap;\n");
    rust_code.push_str("use serde_json::Value;\n");
    rust_code.push_str("use uuid::Uuid;\n\n");
    
    for (name, model_schema) in models {
        if let Some(properties) = model_schema.get("properties").and_then(|v| v.as_object()) {
            rust_code.push_str("#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]\n");
            rust_code.push_str("#[serde(rename_all = \"camelCase\")]\n");
            rust_code.push_str(&format!("pub struct {} {{\n", name));

            for (field_name, field_schema) in properties {
                let mut safe_field_name = field_name.clone();
                if field_name == "match" {
                    safe_field_name = "match_result".to_string();
                }

                let mut rust_type = json_type_to_rust(field_schema);

                let is_required = model_schema.get("required")
                    .and_then(|v| v.as_array())
                    .map_or(false, |r| r.iter().any(|req| req.as_str() == Some(field_name)));

                if !is_required {
                    rust_type = format!("Option<{}>", rust_type);
                }
                
                if field_name == "match" {
                    rust_code.push_str(&format!("    #[serde(rename = \"match\"{})]\n", if !is_required {", default"} else {""}));
                } else if !is_required {
                    rust_code.push_str("    #[serde(default)]\n");
                }
                
                rust_code.push_str(&format!("    pub {}: {},\n", safe_field_name, rust_type));
            }
            rust_code.push_str("}\n\n");
        } else if let Some(enum_vals) = model_schema.get("enum").and_then(|v| v.as_array()) {
            rust_code.push_str("#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n");
            rust_code.push_str("#[serde(rename_all = \"camelCase\")]\n");
            rust_code.push_str(&format!("pub enum {} {{\n", name));
            for val in enum_vals {
                if let Some(s) = val.as_str() {
                    let variant_name = s.replace("-", "_").to_uppercase();
                    rust_code.push_str(&format!("    #[serde(rename = \"{}\")]\n", s));
                    rust_code.push_str(&format!("    {},\n", variant_name));
                }
            }
            rust_code.push_str("}\n\n");
        }
    }

    rust_code
} 